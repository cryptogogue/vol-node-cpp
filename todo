Mining reward
command line wallet

users have accounts
users can be individuals or legal entities
accounts have keys
key have permissions
keys are unique to accounts
accounts hold currency and assets

if a user identity is stolen
    - freeze all accounts
    - re-establish identity (multiple trusted parties)

- open and fund account (user, account, account key)

- new account (and user)
    - must be funded by sponsor

- identify user (notary)
- attach signing keys
- make proclamation (revokable within time limit)

- create account (with owner)
- account policy (overflow, keepalive, demurrage, etc.)
- account user policy
    - user groups
    - add/remove keys
- transfer VOL
    - transfer immediately
    - schedule transfer
    - cancel transfer

- publish proclamation
- publish schema

asset transformation rules
f ( A ) -> B
f ( A, B ) -> C
f ( A, B+ ) -> C
f ( A, B * N ) -> C

declare mining reward
declare asset types
declare data tables
declare lua chunks

can always transfer an asset
parameters - assets ( N, N or more)
multistep (requires miner entropy)
cost
base asset + customization

broad phase: type
medium phase: keywords
narrow phase: metadata

----------------------------------------------------------------

rework asset tracking - no generics; every asset to be unique
    decide on final asset identifier format
    implement asset customization
implement queue of transactions in wallet - rebuild state dynamically (from node)
    rethink state handling in wallet
template cards using SVG and mustache
svg barcode
card modification through crafting
variable-size transactions (multiple crafting commands per transaction)
expand schema to include svg templates AND placeholder asset templates
finalize schema

wallet
    collection screen
        filtering
        printing
        indicate craftability
    crafting model
    rendering svg

validator app - sample

VOL:ETH
onboarding
bearer bond vs oracles
